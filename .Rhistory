bgX <- crayon::make_style("#91b1ce", bg = TRUE)
bgX <- crayon::make_style("#91b1ce", bg = TRUE)
bgY <- crayon::make_style("#5c5eb7", bg = TRUE)
bgZ <- crayon::make_style("#5cb7b6", bg = TRUE)
bgD <- crayon::make_style("#b75c8b", bg = TRUE)
bgW <- crayon::make_style("#5cb788", bg = TRUE)
#' class for Channel objects
#' @importFrom R6 R6Class
Channel <- R6Class("Channel",
public = list(
x = NULL, # x-coordinate of centerline
y = NULL, # y-coordinate of centerline
z = NULL, # z-coordinate of centerline
W = NULL, # channel width
D = NULL, # channel depth,
initialize = function(x = NA,
y = NA,
z = NA,
W = NA,
D = NA) {
self$x <- x
self$y <- y
self$z <- z
self$W <- W
self$D <- D
self$report()
},
report = function() {
cli_alert_info(c(
bgX("X coordinate(s) of centerline: "), white$underline$bold(min(self$x)), " ... ", white$underline$bold(max(self$x))))
cli_alert_info(c(
bgY("Y coordinate(s) of centerline: "), white$underline$bold(min(self$y)), " ... ", white$underline$bold(max(self$y))))
cli_alert_info(c(
bgZ("Z coordinate(s) of centerline: "), white$underline$bold(min(self$z)), " ... ", white$underline$bold(max(self$z))))
cli_alert_info(c(
bgW("Channel width: "), white$underline$bold(self$W)))
cli_alert_info(c(
bgD("Channel depth: "), white$underline$bold(self$D)))
}
)
)
channel <- Channel$new(1,2,3,4,5)
library(R6)
channel <- Channel$new(1,2,3,4,5)
#' class for Channel objects
#' @importFrom R6 R6Class
Channel <- R6Class("Channel",
public = list(
x = NULL, # x-coordinate of centerline
y = NULL, # y-coordinate of centerline
z = NULL, # z-coordinate of centerline
W = NULL, # channel width
D = NULL, # channel depth,
initialize = function(x = NA,
y = NA,
z = NA,
W = NA,
D = NA) {
self$x <- x
self$y <- y
self$z <- z
self$W <- W
self$D <- D
self$report()
},
report = function() {
cli_alert_info(c(
bgX("X coordinate(s) of centerline: "), white$underline$bold(min(self$x)), " ... ", white$underline$bold(max(self$x))))
cli_alert_info(c(
bgY("Y coordinate(s) of centerline: "), white$underline$bold(min(self$y)), " ... ", white$underline$bold(max(self$y))))
cli_alert_info(c(
bgZ("Z coordinate(s) of centerline: "), white$underline$bold(min(self$z)), " ... ", white$underline$bold(max(self$z))))
cli_alert_info(c(
bgW("Channel width: "), white$underline$bold(self$W)))
cli_alert_info(c(
bgD("Channel depth: "), white$underline$bold(self$D)))
}
)
)
channel <- Channel$new(1,2,3,4,5)
library(cli)
channel <- Channel$new(1,2,3,4,5)
cray
#' class for Channel objects
#' @importFrom R6 R6Class
Channel <- R6Class("Channel",
public = list(
x = NULL, # x-coordinate of centerline
y = NULL, # y-coordinate of centerline
z = NULL, # z-coordinate of centerline
W = NULL, # channel width
D = NULL, # channel depth,
initialize = function(x = NA,
y = NA,
z = NA,
W = NA,
D = NA) {
self$x <- x
self$y <- y
self$z <- z
self$W <- W
self$D <- D
self$report()
},
report = function() {
cli_alert_info(c(
bgX("X coordinate(s) of centerline: "), underline$bold(min(self$x)), " ... ", underline$bold(max(self$x))))
cli_alert_info(c(
bgY("Y coordinate(s) of centerline: "), underline$bold(min(self$y)), " ... ", underline$bold(max(self$y))))
cli_alert_info(c(
bgZ("Z coordinate(s) of centerline: "), underline$bold(min(self$z)), " ... ", underline$bold(max(self$z))))
cli_alert_info(c(
bgW("Channel width: "), underline$bold(self$W)))
cli_alert_info(c(
bgD("Channel depth: "), underline$bold(self$D)))
}
)
)
channel <- Channel$new(1,2,3,4,5)
#' class for Channel objects
#' @importFrom R6 R6Class
Channel <- R6Class("Channel",
public = list(
x = NULL, # x-coordinate of centerline
y = NULL, # y-coordinate of centerline
z = NULL, # z-coordinate of centerline
W = NULL, # channel width
D = NULL, # channel depth,
initialize = function(x = NA,
y = NA,
z = NA,
W = NA,
D = NA) {
self$x <- x
self$y <- y
self$z <- z
self$W <- W
self$D <- D
self$report()
},
report = function() {
cli_alert_info(c(
bgX("X coordinate(s) of centerline: "), crayon::underline$bold(min(self$x)), " ... ", crayon::underline$bold(max(self$x))))
cli_alert_info(c(
bgY("Y coordinate(s) of centerline: "), crayon::underline$bold(min(self$y)), " ... ", crayon::underline$bold(max(self$y))))
cli_alert_info(c(
bgZ("Z coordinate(s) of centerline: "), crayon::underline$bold(min(self$z)), " ... ", crayon::underline$bold(max(self$z))))
cli_alert_info(c(
bgW("Channel width: "), crayon::underline$bold(self$W)))
cli_alert_info(c(
bgD("Channel depth: "), crayon::underline$bold(self$D)))
}
)
)
channel <- Channel$new(1,2,3,4,5)
#' class for Channel objects
#' @importFrom R6 R6Class
Channel <- R6Class("Channel",
public = list(
x = NULL, # x-coordinate of centerline
y = NULL, # y-coordinate of centerline
z = NULL, # z-coordinate of centerline
W = NULL, # channel width
D = NULL, # channel depth,
initialize = function(x = NA,
y = NA,
z = NA,
W = NA,
D = NA) {
self$x <- x
self$y <- y
self$z <- z
self$W <- W
self$D <- D
self$report()
},
report = function() {
cli_alert_info(c(
bgX("X coordinate(s) of centerline: ", crayon::underline$bold(min(self$x)), " ... ", crayon::underline$bold(max(self$x)))))
cli_alert_info(c(
bgY("Y coordinate(s) of centerline: ", crayon::underline$bold(min(self$y)), " ... ", crayon::underline$bold(max(self$y)))))
cli_alert_info(c(
bgZ("Z coordinate(s) of centerline: ", crayon::underline$bold(min(self$z)), " ... ", crayon::underline$bold(max(self$z)))))
cli_alert_info(c(
bgW("Channel width: ", crayon::underline$bold(self$W))))
cli_alert_info(c(
bgD("Channel depth: ", crayon::underline$bold(self$D))))
}
)
)
channel <- Channel$new(1,2,3,4,5)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
W = 200.0                    # channel width (m)
D = 16.0                     # channel depth (m)
pad = 100                    # padding (number of nodepoints along centerline)
deltas = 50.0                # sampling distance along centerline
n_bends = 30                 # approximate number of bends you want to model
test <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
Sl = 0.0                     # initial slope (setting this to non-zero results in instabilities in long runs)
test <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
Sl = 0.1                     # initial slope (setting this to non-zero results in instabilities in long runs)
test <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
Sl = 00                     # initial slope (setting this to non-zero results in instabilities in long runs)
Sl = 0                    # initial slope (setting this to non-zero results in instabilities in long runs)
test <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
channel <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
.Random.seed
et(".Random.seed", 1)
get(".Random.seed", 1)
seed = 42
.Random.seed <- seed
rnorm(5)
seed = 42L
.Random.seed <- seed
rnorm(5)
seed = 99822256L
.Random.seed <- seed
rnorm(5)
seed
.Random.seed <- as.integer(seed)
rnorm(5)
?.Random.seed
options_meander <- function(seed = 42) {
set.seed(seed)
rnorm(5)
on.exit(assign(".Random.seed", seed, 1))
}
devtools::load_all(".")
devtools::load_all(".")
source("~/Documents/code/rpkgs/meander/R/zzz.R")
devtools::load_all(".")
devtools::load_all(".")
source("~/Documents/code/rpkgs/meander/R/zzz.R")
devtools::load_all(".")
devtools::load_all(".")
rnorm(6)
rnorm(6)
rnorm(6)
rnorm(6)
options_meander()
rnorm(6)
rnorm(6)
rnorm(6)
rnorm(6)
rnorm(6)
set.seed(5)
rnorm(6)
rnorm(6)
rnorm(6)
rnorm(6)
rnorm(6)
rnorm(6)
set.seed(1)
rnorm(4)
set.seed(1)
rnorm(4)
set.seed(seed)
seed = 42
set.seed(seed)
set.seed(seed)
set.seed(seed)
set.seed(seed)
set.seed(seed)
set.seed(seed)
set.seed(seed)
usethis::use_package("pragma")
usethis::use_package("pracma")
compute_derivatives <- function(x,y,z){
dx = gradient(x) # first derivatives
dy = gradient(y)
dz = gradient(z)
ds = sqrt(dx^2+dy^2+dz^2)
s  = c(0,np.cumsum(ds[-1]))
return(list(dx, dy, dz, ds, s))
}
W = 200.0                    # channel width (m)
D = 16.0                     # channel depth (m)
pad = 100                    # padding (number of nodepoints along centerline)
deltas = 50.0                # sampling distance along centerline
n_bends = 30                 # approximate number of bends you want to model
Sl = 0                    # initial slope (setting this to non-zero results in instabilities in long runs)
channel <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
generate_initial_channel <- function(W,
D,
Sl,
deltas,
pad,
n_bends) {
# length of noisy part of initial centerline
noisy_len = n_bends*10*W/2.0
# padding at upstream end can be shorter than padding on downstream end
pad1 = as.integer(pad/10.0)
if(pad1<5L) pad1 = 5
# x coordinate
x = seq(0, noisy_len+(pad+pad1)*deltas, length.out = as.integer(noisy_len/deltas+pad+pad1)+1)
# y coordinate
y = 10L * (2L * runif(as.integer(noisy_len/deltas) +1) - 1)
y = c(rep(0, pad1), y, rep(0, pad))
# z coordinate
deltaz = Sl * deltas*(length(x)-1)
z = rev(seq(0, deltaz, length.out = length(x)))
# return Channel object
return(Channel$new(x,y,z,W,D))
}
channel <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
#' class for Channel objects
#' @importFrom R6 R6Class
Channel <- R6::R6Class("Channel",
public = list(
x = NULL, # x-coordinate of centerline
y = NULL, # y-coordinate of centerline
z = NULL, # z-coordinate of centerline
W = NULL, # channel width
D = NULL, # channel depth,
initialize = function(x = NA,
y = NA,
z = NA,
W = NA,
D = NA) {
self$x <- x
self$y <- y
self$z <- z
self$W <- W
self$D <- D
self$report()
},
report = function() {
cli_alert_info(c(
bgX("X coordinate(s) of centerline: ", crayon::underline$bold(min(self$x)), " ... ", crayon::underline$bold(max(self$x)))))
cli_alert_info(c(
bgY("Y coordinate(s) of centerline: ", crayon::underline$bold(min(self$y)), " ... ", crayon::underline$bold(max(self$y)))))
cli_alert_info(c(
bgZ("Z coordinate(s) of centerline: ", crayon::underline$bold(min(self$z)), " ... ", crayon::underline$bold(max(self$z)))))
cli_alert_info(c(
bgW("Channel width: ", crayon::underline$bold(self$W))))
cli_alert_info(c(
bgD("Channel depth: ", crayon::underline$bold(self$D))))
}
)
)
generate_initial_channel <- function(W,
D,
Sl,
deltas,
pad,
n_bends) {
# length of noisy part of initial centerline
noisy_len = n_bends*10*W/2.0
# padding at upstream end can be shorter than padding on downstream end
pad1 = as.integer(pad/10.0)
if(pad1<5L) pad1 = 5
# x coordinate
x = seq(0, noisy_len+(pad+pad1)*deltas, length.out = as.integer(noisy_len/deltas+pad+pad1)+1)
# y coordinate
y = 10L * (2L * runif(as.integer(noisy_len/deltas) +1) - 1)
y = c(rep(0, pad1), y, rep(0, pad))
# z coordinate
deltaz = Sl * deltas*(length(x)-1)
z = rev(seq(0, deltaz, length.out = length(x)))
# return Channel object
return(Channel$new(x,y,z,W,D))
}
channel <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
devtools::load_all(".")
devtools::load_all(".")
channel <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
library(crayon)
library(cli)
channel <- generate_initial_channel(W,D,Sl,deltas,pad,n_bends)
channel
channel$x
compute_derivatives(channel$x, channel$y, channel$z)
library(pracma)
compute_derivatives(channel$x, channel$y, channel$z)
compute_derivatives <- function(x,y,z){
dx = gradient(x) # first derivatives
dy = gradient(y)
dz = gradient(z)
ds = sqrt(dx^2+dy^2+dz^2)
s  = c(0, cumsum(ds[-1]))
return(list(dx, dy, dz, ds, s))
}
compute_derivatives(channel$x, channel$y, channel$z)
x
x = channel$x
y = channel$y
z = channel$z
ns = length(x)
ns = length(x)
ns
curv =  list(x,y)
derivatives_dx_dy_dz_ds_s = compute_derivatives(x,y,z)
sinuosity = derivatives_dx_dy_dz_ds_s$s[length(derivatives_dx_dy_dz_ds_s$s)]/(x[length(x)]-x[1])
sinuosity
derivatives_dx_dy_dz_ds_s$s[length(derivatives_dx_dy_dz_ds_s$s)]
derivatives_dx_dy_dz_ds_s
derivatives_dx_dy_dz_ds_s$s
compute_derivatives <- function(x,y,z){
dx = gradient(x) # first derivatives
dy = gradient(y)
dz = gradient(z)
ds = sqrt(dx^2+dy^2+dz^2)
s  = c(0, cumsum(ds[-1]))
return(list("dx" = dx, "dy" = dy, "dz" = dz, "ds" = ds, "s" = s))
}
derivatives_dx_dy_dz_ds_s = compute_derivatives(x,y,z)
derivatives_dx_dy_dz_ds_s
derivatives_dx_dy_dz_ds_s$s
derivatives_dx_dy_dz_ds_s$s[length(derivatives_dx_dy_dz_ds_s$s)]
derivatives_dx_dy_dz_ds_s$s[length(derivatives_dx_dy_dz_ds_s$s)]/(x[length(x)]-x[1])
x
x[length(x)]
x[1]
sinuosity = derivatives_dx_dy_dz_ds_s$s[length(derivatives_dx_dy_dz_ds_s$s)]/(x[length(x)]-x[1])
curv = W*curv # dimensionless curvature
W
W = 200
curv
