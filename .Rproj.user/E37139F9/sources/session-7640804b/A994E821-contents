import numpy as np
W = 200.0                    # channel width (m)
D = 16.0                     # channel depth (m)
pad = 100                    # padding (number of nodepoints along centerline)
deltas = 50.0                # sampling distance along centerline
nit = 1500                   # number of iterations
Cf = 0.03                    # dimensionless Chezy friction factor
crdist = W                   # threshold distance at which cutoffs occur
kl = 60.0/(365*24*60*60.0)   # migration rate constant (m/s)
kv =  3*10*5.0E-13           # vertical slope-dependent erosion rate constant (m/s)
dt = 0.1*(365*24*60*60.0)    # time step (s)
dens = 1000                  # density of water (kg/m3)
saved_ts = 20                # which time steps will be saved
n_bends = 30                 # approximate number of bends you want to model
Sl = 0.0                     # initial slope (setting this to non-zero results in instabilities in long runs)

noisy_len = n_bends*10*W/2.0 # length of noisy part of initial centerline
pad1 = int(pad/10.0) # padding at upstream end can be shorter than padding on downstream end
if pad1<5:
  pad1 = 5
x = np.linspace(0, noisy_len+(pad+pad1)*deltas, int(noisy_len/deltas+pad+pad1)+1) # x coordinate
y = 10.0 * (2*np.random.random_sample(int(noisy_len/deltas)+1,)-1)
a = np.array((1,2,3))
b = np.array((4,5,6))
c = np.array((7,8,9))
np.hstack((a,b,c))
y = np.hstack((np.zeros((pad1),),y,np.zeros((pad),))) # y coordinate
deltaz = Sl * deltas*(len(x)-1)
z = np.linspace(0,deltaz,len(x))[::-1] # z coordinate